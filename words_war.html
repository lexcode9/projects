<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Words War</title>
<style>
html, body {
margin: 0;
padding: 0;
height: 100%;
font-family: monospace;
box-sizing: border-box;
background: white;
}

body {
display: grid;
grid-template-columns: 2.5% 20% 2.5% 50% 2.5% 20% 2.5%;
grid-template-rows:
auto       
auto      
1fr        
auto      
auto       
auto       
auto;      
height: 100vh;
}

h2 {
grid-column: 1 / 8;
grid-row: 1;
margin: 0;
padding: 10px 0;
text-align: center;
}

#speed-control {
grid-column: 2 / 7;
grid-row: 2;
padding: 10px;
text-align: center;
font-family: monospace;
background: white;
z-index: 1;
}

#left-panel {
grid-column: 2 / 3;
grid-row: 3;
border: 1px solid #000;
padding: 10px;
box-sizing: border-box;
overflow-y: auto;
height: 100%;
}

#stage {
grid-column: 4 / 5;
grid-row: 3;
border: 1px solid #000;
padding: 10px;
box-sizing: border-box;
height: 100%;
display: flex;
flex-direction: column;
justify-content: space-between;
}

#right-panel {
grid-column: 6 / 7;
grid-row: 3;
border: 1px solid #000;
padding: 10px;
box-sizing: border-box;
overflow-y: auto;
height: 100%;
}

#panel {
width: 100%;
flex-grow: 1;
display: flex;
flex-direction: column;
justify-content: space-between;
}

.team {
display: flex;
justify-content: center;
gap: 20px;
flex-wrap: wrap;
}

.letter-container {
display: flex;
flex-direction: column;
align-items: center;
position: relative;
}

.letter {
width: 12vmin;
height: 12vmin;
font-size: 8vmin;
line-height: 12vmin;
text-align: center;
user-select: none;
transition: opacity 0.3s;
}

.dead {
opacity: 0.1;
}

.hp-bar {
width: 12vmin;
height: 1.2vmin;
border: 0.1vmin solid black;
background-color: #ddd;
margin-top: 0.5vmin;
position: relative;
overflow: hidden;
box-sizing: border-box;
}

.hp-fill {
height: 100%;
background-color: #4caf50;
width: 100%;
position: absolute;
top: 0;
left: 0;
transition: width 0.3s ease;
}

.attacker-clone {
position: absolute;
z-index: 100;
width: 12vmin;
height: 12vmin;
font-size: 8vmin;
line-height: 12vmin;
text-align: center;
pointer-events: none;
}

#result {
grid-column: 2 / 7;
grid-row: 4;
height: 24px;
font-weight: bold;
text-align: center;
margin: 10px 0;
}

#word-input {
grid-column: 2 / 7;
grid-row: 5;
font-family: monospace;
font-size: 16px;
padding: 4px;
width: 200px;
margin: 0 auto;
display: block;
text-transform: uppercase;
text-align: center;
}

#fight-button {
grid-column: 2 / 7;
grid-row: 6;
padding: 8px 16px;
font-family: monospace;
font-size: 16px;
cursor: pointer;
margin: 10px auto 0;
display: block;
}

#fight-button:disabled {
cursor: not-allowed;
opacity: 0.5;
}

#stats-display {
grid-column: 2 / 7;
grid-row: 7;
font-size: 16px;
}

@keyframes shake {
0% { transform: translateX(0); }
25% { transform: translateX(-4px); }
50% { transform: translateX(4px); }
75% { transform: translateX(-4px); }
100% { transform: translateX(0); }
}

.shake {
animation: shake 0.2s;
}

.panel-title {
font-weight: bold;
margin-bottom: 10px;
}

ul {
padding-left: 20px;
margin: 0;
max-height: 80vh;
overflow-y: auto;
}


@media (min-width: 1000px) {
.letter {
width: 60px;
height: 60px;
font-size: 36px;
line-height: 60px;
}

.hp-bar {
width: 60px;
height: 8px;
border: 1px solid black;
margin-top: 4px;
}

.attacker-clone {
width: 60px;
height: 60px;
font-size: 36px;
line-height: 60px;
}
}

</style>
</head>
<body>

<h2>Words War</h2>



<div id="left-panel">
<div class="panel-title">Your Words</div>
<ul id="word-history"></ul>
</div>

<div id="speed-control">
<input type="range" id="speedSlider" min="1" max="3" step="1" value="2">
Game Speed: <span id="speedLabel">Normal</span>
</div>

<div id="stage">
<div id="panel">
<div id="ai" class="team"></div>
<div id="player" class="team"></div>
</div>
</div>

<div id="right-panel">
<div class="panel-title">Enemy</div>
<ul id="enemy-info"></ul>
</div>

<div id="result">Enter a word that matches the length</div>

<input type="text" id="word-input" placeholder="Type your word" disabled />

<button id="fight-button" disabled>Fight</button>
<div id="stats-display" style="grid-column: 2 / 7; grid-row: 7; font-size: 16px;"></div>

<script>

let duration = 200;
const aiTeam = document.getElementById("ai");
const playerTeam = document.getElementById("player");
const resultEl = document.getElementById("result");
const input = document.getElementById("word-input");
const fightBtn = document.getElementById("fight-button");
const aiHistoryEl = document.getElementById("enemy-info");
const playerHistoryEl = document.getElementById("word-history");

const usedWords = new Set();

async function fetchValidWord(min = 3, max = 5) {
while (true) {
const length = Math.floor(Math.random() * (max - min + 1)) + min;
try {
const response = await fetch(`https://api.datamuse.com/words?sp=${'?'.repeat(length)}&max=1000`);
const words = await response.json();
const filtered = words.filter(w =>
(!w.tags || !w.tags.includes('abbr')) &&
/^[a-z]+$/.test(w.word) &&
!usedWords.has(w.word.toUpperCase())
);
if (filtered.length === 0) continue;
const chosen = filtered[Math.floor(Math.random() * filtered.length)];
if (chosen.word.length === length && !usedWords.has(chosen.word.toUpperCase())) {
return chosen.word.toUpperCase();
}
} catch (e) {
return generateRandomWord(min, max);
}
}
}

function generateRandomWord(min = 3, max = 5) {
const length = Math.floor(Math.random() * (max - min + 1)) + min;
return Array.from({ length }, () =>
String.fromCharCode(65 + Math.floor(Math.random() * 26))
).join('');
}

function createLetterWithHP(letter) {
const container = document.createElement("div");
container.className = "letter-container";

const letterDiv = document.createElement("div");
letterDiv.className = "letter";
letterDiv.textContent = letter;

const hpBar = document.createElement("div");
hpBar.className = "hp-bar";

const hpFill = document.createElement("div");
hpFill.className = "hp-fill";
hpFill.style.width = "100%";

hpBar.appendChild(hpFill);
container.appendChild(letterDiv);
container.appendChild(hpBar);

return container;
}

const slider = document.getElementById('speedSlider');
const speedLabel = document.getElementById('speedLabel');

const speedMap = {
1: 'Normal',
2: 'Fast',
3: 'Very Fast'
};

function updateSpeed(value) {
speedLabel.textContent = speedMap[value];
duration = 160-(value*50);

}

slider.addEventListener('input', () => {
updateSpeed(slider.value);
});

updateSpeed(slider.value);

const letterStats = {
A: { hp: 125, damage: 80, accuracy: 30, evasion: 20 },
B: { hp: 135, damage: 42, accuracy: 34, evasion: 19 },
C: { hp: 110, damage: 37, accuracy: 22, evasion: 11 },
D: { hp: 142, damage: 45, accuracy: 38, evasion: 26 },
E: { hp: 156, damage: 50, accuracy: 38, evasion: 25 },
F: { hp: 108, damage: 49, accuracy: 24, evasion: 10 },
G: { hp: 130, damage: 30, accuracy: 28, evasion: 17 },
H: { hp: 115, damage: 38, accuracy: 32, evasion: 21 },
I: { hp: 125, damage: 40, accuracy: 30, evasion: 40 },
J: { hp: 105, damage: 44, accuracy: 21, evasion: 13 },
K: { hp: 138, damage: 36, accuracy: 30, evasion: 29 },
L: { hp: 122, damage: 48, accuracy: 33, evasion: 24 },
M: { hp: 109, damage: 34, accuracy: 40, evasion: 20 },
N: { hp: 145, damage: 39, accuracy: 25, evasion: 18 },
O: { hp: 250, damage: 40, accuracy: 30, evasion: 20 },
P: { hp: 127, damage: 32, accuracy: 26, evasion: 27 },
Q: { hp: 101, damage: 43, accuracy: 20, evasion: 23 },
R: { hp: 133, damage: 31, accuracy: 23, evasion: 15 },
S: { hp: 144, damage: 46, accuracy: 35, evasion: 28 },
T: { hp: 111, damage: 40, accuracy: 39, evasion: 22 },
U: { hp: 125, damage: 40, accuracy: 60, evasion: 20 },
V: { hp: 117, damage: 38, accuracy: 34, evasion: 26 },
W: { hp: 134, damage: 49, accuracy: 21, evasion: 30 },
X: { hp: 119, damage: 30, accuracy: 27, evasion: 17 },
Y: { hp: 141, damage: 33, accuracy: 25, evasion: 14 },
Z: { hp: 106, damage: 45, accuracy: 38, evasion: 13 }
};


function getLetterStats(letter) {
return letterStats[letter];
}

function renderLetterStats() {
const container = document.getElementById("stats-display");
container.innerHTML = "";

const table = document.createElement("table");
table.style.width = "100%";
table.style.borderCollapse = "collapse";
table.style.textAlign = "center";
table.style.fontSize = "14px";

function createCell(tag, text) {
const cell = document.createElement(tag);
cell.textContent = text;
cell.style.border = "1px solid #ccc";
cell.style.padding = "4px";
return cell;
}

const headerRow = document.createElement("tr");
headerRow.appendChild(createCell("th", ""));
for (const letter of Object.keys(letterStats)) {
headerRow.appendChild(createCell("th", letter));
}
table.appendChild(headerRow);

const stats = ["hp", "damage", "accuracy", "evasion"];
const statNames = { hp: "HP", damage: "Damage", accuracy: "Accuracy", evasion: "Evasion" };

for (const stat of stats) {
const row = document.createElement("tr");
row.appendChild(createCell("th", statNames[stat]));
for (const letter of Object.keys(letterStats)) {
row.appendChild(createCell("td", letterStats[letter][stat]));
}
table.appendChild(row);
}

container.appendChild(table);
}


renderLetterStats();



function sanitizeInput(str) {
return str.toUpperCase().replace(/[^A-Z]/g, "");
}

function getAliveLetters(teamEl) {
return Array.from(teamEl.children).filter(l => !l.querySelector(".letter").classList.contains("dead"));
}

function addWordToHistory(listEl, word) {
const li = document.createElement("li");
li.textContent = word;
listEl.appendChild(li);
}

function killLetter(letterContainer) {
const letterEl = letterContainer.querySelector(".letter");
letterEl.classList.add("dead");
const hpFill = letterContainer.querySelector(".hp-fill");
hpFill.style.width = "0%";
}

function shakeElement(el, type) {
el.classList.add("shake");
el.style.animationDuration = type === "miss" ? "0.1s" : "0.2s";
setTimeout(() => {
el.classList.remove("shake");
el.style.animationDuration = "";
}, type === "miss" ? 100 : 200);
}


function getAliveLetters(teamEl) {
return Array.from(teamEl.querySelectorAll(".letter-container")).map(container => {
const letter = container.querySelector(".letter");
return letter.classList.contains("dead") ? null : letter;
}).filter(Boolean);
}

function animateAttack(attackerEl, defenderEl, callback) {
const aRect = attackerEl.getBoundingClientRect();
const dRect = defenderEl.getBoundingClientRect();
const dx = dRect.left - aRect.left;
const dy = dRect.top - aRect.top;
const originalTransform = attackerEl.style.transform || "";

let start = null;

function moveForward(timestamp) {
if (!start) start = timestamp;
const progress = Math.min((timestamp - start) / duration, 1);
attackerEl.style.transform = `translate(${dx * progress}px, ${dy * progress}px)`;
if (progress < 1) {
requestAnimationFrame(moveForward);
} else {
const acc = parseInt(attackerEl.dataset.accuracy, 10) || 0;
const eva = parseInt(defenderEl.dataset.evasion, 10) || 0;
const hitChance = 50 + (acc - eva);
const hit = Math.random() * 100 < hitChance;

if (hit) {
const damage = parseInt(attackerEl.dataset.damage, 10);
let defenderHP = parseInt(defenderEl.dataset.hp, 10) - damage;
defenderHP = Math.max(defenderHP, 0);
defenderEl.dataset.hp = defenderHP;

showFloatingText(defenderEl.parentElement, damage);

const hpFill = defenderEl.parentElement.querySelector(".hp-fill");
if (hpFill) {
const maxHp = parseInt(defenderEl.dataset.maxHp, 10);
hpFill.style.width = (defenderHP / maxHp) * 100 + '%';
}

if (defenderHP === 0) {
killLetter(defenderEl.parentElement);
}

shakeElement(defenderEl.parentElement, "hit");
} else {
showFloatingText(defenderEl.parentElement, "MISS");
}

setTimeout(() => {
start = null;
requestAnimationFrame(function moveBack(timestamp) {
if (!start) start = timestamp;
const backProgress = Math.min((timestamp - start) / duration, 1);
attackerEl.style.transform = `translate(${dx * (1 - backProgress)}px, ${dy * (1 - backProgress)}px)`;
if (backProgress < 1) {
requestAnimationFrame(moveBack);
} else {
attackerEl.style.transform = originalTransform;
callback(hit);
}
});
}, 200);
}
}
requestAnimationFrame(moveForward);
}

function showFloatingText(container, text) {
const floatText = document.createElement("div");
floatText.textContent = text;
floatText.style.position = "absolute";
floatText.style.left = "50%";
floatText.style.top = "0";
floatText.style.transform = "translateX(-50%)";
floatText.style.color = text === "MISS" ? "gray" : "red";
floatText.style.fontWeight = "bold";
floatText.style.pointerEvents = "none";
floatText.style.userSelect = "none";
floatText.style.transition = "transform 1s ease-out, opacity 1s ease-out";
container.style.position = "relative";
container.appendChild(floatText);

requestAnimationFrame(() => {
floatText.style.transform = "translateX(-50%) translateY(-40px)";
floatText.style.opacity = "0";
});

setTimeout(() => {
container.removeChild(floatText);
}, 1000);
}

function createTeamFromWord(teamEl, word) {
teamEl.innerHTML = "";
for (const ch of word) {
const container = document.createElement("div");
container.className = "letter-container";

const letter = document.createElement("div");
letter.className = "letter";
letter.textContent = ch;

const stats = getLetterStats(ch);
letter.dataset.hp = stats.hp;
letter.dataset.maxHp = stats.hp;
letter.dataset.damage = stats.damage;

const hpBar = document.createElement("div");
hpBar.className = "hp-bar";

const hpFill = document.createElement("div");
hpFill.className = "hp-fill";
hpFill.style.width = "100%";

hpBar.appendChild(hpFill);
container.appendChild(letter);
container.appendChild(hpBar);
teamEl.appendChild(container);
}
}




function fightLoop(attackerTeam, defenderTeam, onDone) {
const attackers = getAliveLetters(attackerTeam);
const defenders = getAliveLetters(defenderTeam);
if (attackers.length === 0 || defenders.length === 0) {
onDone();
return;
}
const attacker = attackers[Math.floor(Math.random() * attackers.length)];
const defender = defenders[Math.floor(Math.random() * defenders.length)];
animateAttack(attacker, defender, (hit) => {
if (getAliveLetters(defenderTeam).length === 0) return onDone();
setTimeout(() => {
fightLoop(defenderTeam, attackerTeam, onDone);
}, 300);
});
}

function resetStage(aiWord, playerWord) {
createTeamFromWord(aiTeam, aiWord);
createTeamFromWord(playerTeam, playerWord);
}

let currentAIWord = "";
let currentPlayerWord = "";

async function startNewRound() {
resultEl.textContent = "Loading AI word...";
input.disabled = true;
fightBtn.disabled = true;
currentAIWord = await fetchValidWord(3, 5);
usedWords.add(currentAIWord);
addWordToHistory(aiHistoryEl, currentAIWord);
resetStage(currentAIWord, "");
input.disabled = false;
input.value = "";
input.setAttribute("maxlength", currentAIWord.length);
input.placeholder = `Type a word`;
resultEl.textContent = `Enter a word that matches the length 0/${currentAIWord.length}`;
fightBtn.disabled = true;
}

startNewRound();

input.addEventListener("input", async () => {
input.value = sanitizeInput(input.value);
const currentLength = input.value.length;
const maxLength = currentAIWord.length;
if (currentLength === maxLength) {
if (usedWords.has(input.value)) {
resultEl.textContent = `Word already used! Try another. (${currentLength}/${maxLength})`;
fightBtn.disabled = true;
return;
}
resultEl.textContent = `Ready to fight! (${currentLength}/${maxLength})`;
fightBtn.disabled = false;
} else {
resultEl.textContent = `Enter a word that matches the length ${currentLength}/${maxLength}`;
fightBtn.disabled = true;
}
});

fightBtn.addEventListener("click", () => {
currentPlayerWord = input.value;
usedWords.add(currentPlayerWord);
addWordToHistory(playerHistoryEl, currentPlayerWord);
resetStage(currentAIWord, currentPlayerWord);
input.disabled = true;
fightBtn.disabled = true;
resultEl.textContent = "Fight started!";

const firstAttacker = Math.random() < 0.5 ? playerTeam : aiTeam;
const firstDefender = firstAttacker === playerTeam ? aiTeam : playerTeam;

fightLoop(firstAttacker, firstDefender, () => {
const playerAlive = getAliveLetters(playerTeam).length;
const aiAlive = getAliveLetters(aiTeam).length;
if (playerAlive === 0 && aiAlive > 0) {
resultEl.textContent = "AI wins!";
setTimeout(() => {
createTeamFromWord(playerTeam, "");
resetStage(currentAIWord, "");
resultEl.textContent = "Enter a word that matches the length";
input.disabled = false;
input.value = "";
input.setAttribute("maxlength", currentAIWord.length);
}, 1000);
} else if (aiAlive === 0 && playerAlive > 0) {
resultEl.textContent = "Player wins!";
setTimeout(() => {
startNewRound();
}, 1000);
} else {
resultEl.textContent = "Draw!";
setTimeout(() => {
startNewRound();
}, 1000);
}
});
});
</script>
</body>
</html>
