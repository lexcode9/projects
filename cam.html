<!DOCTYPE html>
<html>
<head>
  <title>Cam1</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    #video {
      position: absolute;
      top: 0;
      left: 0;
      width: 640px;
      height: 480px;
      background: black;
      object-fit: cover;
      transform: scaleX(-1); /* Flip video horizontally */
    }
    #circle {
      position: absolute;
      width: 20px;
      height: 20px;
      background: red;
      border-radius: 50%;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <video id="video" autoplay muted playsinline></video>
  <div id="circle"></div>

  <script>
    const video = document.getElementById('video');
    const circle = document.getElementById('circle');

    async function startCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        await video.play();
      } catch (err) {
        alert('Camera error: ' + err);
      }
    }

    startCamera();
  </script>

  <!-- TensorFlow.js and face-api.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/face-api.js"></script>

  <script>
    async function loadModels() {
      await faceapi.nets.tinyFaceDetector.loadFromUri('/models');
      await faceapi.nets.faceLandmark68TinyNet.loadFromUri('/models');
    }

    async function trackNose() {
      const detection = await faceapi
        .detectSingleFace(video, new faceapi.TinyFaceDetectorOptions())
        .withFaceLandmarks(true);

      if (detection) {
        const nosePoint = detection.landmarks.getNose()[3]; // Nose tip
        const videoRect = video.getBoundingClientRect();

        // Compensate for the flipped video by mirroring X
        const mirroredX = videoRect.left + (video.videoWidth - nosePoint.x) * (videoRect.width / video.videoWidth);
        const adjustedY = videoRect.top + nosePoint.y * (videoRect.height / video.videoHeight);

        // Position the circle
        circle.style.left = `${mirroredX - circle.offsetWidth / 2}px`;
        circle.style.top = `${adjustedY - circle.offsetHeight / 2}px`;
      }

      requestAnimationFrame(trackNose);
    }

    video.onloadedmetadata = async () => {
      await loadModels();
      trackNose();
    };
  </script>
</body>
</html>
